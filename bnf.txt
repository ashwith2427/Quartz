file := global_scopes | local_scopes

global_scopes := (global_scope)*

global_scope := function | assignment_operation | imports | struct_decl | enumeration

local_scopes := (local_scope)*

local_scope := global_scope | loop | conditional_statement | jump_statement

jump_statement := break | continue | return | return expression

loop := for | while

for := for '(' assignment_operation ';' (condition)? ';' (update_assignment_operation)? ')' '{'
               local_scopes
       '}'

while := while '(' condition ')' '{' local_scopes '}'

conditional_statement := if_case | switch_case

if_case := if (condition) '{' (local_scopes)? '}' (chain)* (else)?

chain := else if(condition) '{' (local_scopes)? '}'

else := else '{' local_scopes '}'

condition := expression equality_op expression

equality_op := '==' | '&&' | '||' | '>=' | '<=' | '!=' | 'and' | 'or'

inline_optional_return := (return)? expression

switch_case := switch '(' expression ')' '{'
                   (case)+
                   default
               '}'

blocked_optional_return := '{' local_scopes (return expression)? '}'

case := expression '=>' (inline_optional_return | blocked_optional_return) ','

default := else '=>' (inline_optional_return | blocked_optional_return)

function := function_declaration | function_definition

function_declaration := identifier '(' (decl_params)? ')' '->' type_specifier

function_definition := identifier '(' (def_params)? ')' '->' type_specifier '=' '{' local_scopes optional_return '}'

optional_return := (return)? | return expression

decl_params := decl_param (',' decl_param)*

decl_param := type_specifier (identifier)?

def_params := def_param (',' def_param)*

def_param := type_specifier identifier

imports := import*

import := import string_literal

struct_decl := struct identifier '{' (members_decl)* '}'

members_decl := member_decl (members_decl)*

member_decl := (static)? new_assignment_expression

struct_initializer := type_specifier identifier (struct_init)?

struct_init := '=' '.' '{' ('.' identifier '=' expression)* '}'

struct_access := identifier '.' identifier

enumeration := enum identifier '{' (identifier)* '}'

enumeration_access := identifier '::' identifier

array_decl := type_specifier identifier array_brackets (array_initializer)?

array_brackets := '[' array_size ']' (array_brackets)*

array_size := expression | Îµ

array_initializer := '=' '{' (expression)* '}'

array_access := identifier '[' expression ']'

assignment_operation := new_assignment_operation | update_assignment_operation

new_assignment_operation := initializer_list

initializer_list := array_decl | struct_initializer | other_initializer

other_initializer := type_specifier identifier '=' expression

update_assignment_operation := access_list assignment_operator expression

access_list := array_access | struct_access | identifier

assignment_operator := '=' | '+=' | '-=' | '*=' | '/=' | '&=' | '^=' | '|=' | '>>=' | '<<=' | '%='

expression := ternary_expression

ternary_expression := logical_or ('?' expression ':' expression)?

logical_or := logical_and ( '||' logical_and )*

logical_and := bitwise_or ( '&&' bitwise_or )*

bitwise_or := bitwise_xor ( '|' bitwise_xor )*

bitwise_xor := bitwise_and ( '^' bitwise_and )*

bitwise_and := equality ( '&' equality )*

equality := relational ( ('==' | '!=') relational )*

relational := additive ( ('<' | '>' | '<=' | '>=') additive )*

additive := multiplicative ( ('+' | '-') multiplicative )*

multiplicative := unary ( ('*' | '/' | '%') unary )*

unary := ('+' | '-' | '!' | '&' | '*')? primary

primary := identifier | literal | array_access | struct_access | '(' expression ')' | function_call | enumeration_access

function_call := identifier '(' (params)? ')'

params := expression (param_chain)*

param_chain := ',' expression

identifier := char (number | char)*

pointer := '*' | '*' pointer

literal := char | string_literal | number | decimal

char := '\'' [anycharacter] '\''

string_literal := '"' (char)* '"'

number := digit (number)*

digit := [0-9]

decimal := number '.' number

type_specifier := builtin_types | user_defined_types

builtin_types := [int, float, char, double] (pointer)?

----------------------------------------------------------------------

TokenKind -> Identifier, CharacterLiteral, StringLiteral, Integer, Character, Float, Long, Double, LeftBracket, RightBracket, LeftBrace, RightBrace, LeftParen, RightParen, Comma, Dot, Plus, Minus, Multiply, Divide, Modulo, LeftShift, RightShift, BinaryOR, BinaryXOR, BinaryAND, Bang, LessThan, GreaterThan, BangEqual, LessThanEqual, GreaterThanEqual, EqualEqual, AssignEqual, AssignAdd, AssignSubtract, AssignMultiply, AssignDivide, AssignModulo, AssignLeftShift, AssignRightShift, AssignBinaryOR, AssignBinaryXOR, AssignBinaryAND, RelationalAND, RelationalOR, QuestionMark, Arrow, Semicolon, Colon, DoubleQuote, SingleQuote, MultiLineQuote, Tilda, Comment, MultilineComment, DocComment

----------------------------------------------------------------------
